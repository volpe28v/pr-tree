#!/usr/bin/env ruby

require 'net/https'
require 'uri'
require 'json'
require 'concurrent'
require 'optparse'

def main
  opt = OptionParser.new
  opt.on('-f', '--filter KEYWORD', 'filter by keyword') { |v| @keyword  = v }
  opt.on('-r', '--reviewer REVIEWER', 'filter by reviewer') { |v| @reviewer = v }
  opt.on('-u', '--url GIT_URL', 'specific git url') { |v| @url = v }
  opt.parse(ARGV)

  git_config = GitConfig.new(@url)
  unless git_config.has_token?
    puts 'Please set the environment variable "GITHUB_API_TOKEN"'
    exit
  end

  unless git_config.github_repo?
    puts 'Run command in github repository or spcify git url with "-u" option.'
    exit
  end

  puts git_config.repo

  github_client = GitHubClient.new(git_config)
  branches, pulls = *Concurrent::Promise.zip(
    Concurrent::Promise.execute { github_client.branches },
    Concurrent::Promise.execute { github_client.pull_requests }
  ).value

  prs = pulls.map do |pr|
    base_branch = branches.find{|b| b['name'] == pr['base']['ref']}
    PrItem.new({
      number: pr['number'],
      title: pr['title'],
      user: pr['user']['login'],
      reviewers: pr['requested_reviewers'].map{|r| r['login']},
      base: pr['base']['ref'],
      is_latest: base_branch.nil? ? true : pr['base']['sha'] == base_branch['commit']['sha'],
      head: pr['head']['ref'],
      url: pr['html_url'],
      status: pr['status']
    })
  end

  prs = prs.select {|pr| pr.user_like(@keyword) }
  prs = prs.select {|pr| pr.reviewer_like(@reviewer) }


  tree_builder = TreeBuilder.new(prs)
  tree_builder.add_top_item {|key| PrItem.new({ head: key }) }
  tree_builder.show
end

class GitConfig
  attr_reader :token, :owner, :repo

  def initialize(url)
    @token = ENV['GITHUB_API_TOKEN']
    @owner, @repo = get_repo_info(url)
  end

  def has_token?
    !token.empty?
  end

  def github_repo?
    !(owner.empty? || repo.empty?)
  end

  private

  def get_repo_info(url)
    url = `git config --get remote.origin.url` if url.nil?

    m = url.match(/git@github.com[:\/](?<owner>.+)\/(?<repo>.+).git/)
    return m[:owner], m[:repo]
  end
end

class GitHubClient
  def initialize(config)
    @token = config.token
    @owner = config.owner
    @repo = config.repo
  end

  def branches
    get_request(branches_uri)
  end

  def pull_requests
    Concurrent::Promise.zip(
      *get_request(pulls_uri).map do |pr|
        Concurrent::Promise.execute do
          pr['status'] = get_request(status_uri(pr['head']['sha']))['state']
          pr
        end
      end
    ).value
  end

  private

  attr_accessor :token, :owner, :repo

  def get_request(uri)
    http = Net::HTTP.new(uri.host, uri.port)

    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    req = Net::HTTP::Get.new(uri.request_uri)
    req["Authorization"] = "token #{token}"

    res = http.request(req)
    unless res.code == '200'
      puts res.code, res.msg
      return nil
    end

    JSON.parse(res.body)
  end

  def pulls_uri
    URI.parse(base_uri + "/pulls")
  end

  def branches_uri
    URI.parse(base_uri + "/branches")
  end

  def status_uri(sha)
    URI.parse(base_uri + "/commits/#{sha}/status")
  end

  def base_uri
    "https://api.github.com/repos/#{owner}/#{repo}"
  end
end

module TreeBuildable
  attr_accessor :children, :parent

  def has_key_in_parent_bases(key)
    raise NotImplementedError, "You must implement #{self.class}##{__method__}"
  end

  def parent_key
    raise NotImplementedError, "You must implement #{self.class}##{__method__}"
  end

  def key
    raise NotImplementedError, "You must implement #{self.class}##{__method__}"
  end

  def texts
    raise NotImplementedError, "You must implement #{self.class}##{__method__}"
  end
end

class TreeBuilder
  def initialize(items)
    @items = items

    build_tree
  end

  def add_top_item
    parents = @items.select { |item| item.parent == nil }
    @items = parents.group_by { |item| item.parent_key }.to_a.map do |item|
      top_item = yield(item[0])
      top_item.children = item[1]
      top_item
    end
  end

  def show
    show_as_tree(@items, '')
  end

  private

  def build_tree
    @items.each do |item|
      parent = @items.select { |p| p.key == item.parent_key && !p.has_key_in_parent_bases(item.key) }.first
      if parent
        parent.children << item
        item.parent = parent
      end
    end
  end

  def show_as_tree(items, prefix)
    return if items.empty?

    items.each_with_index do |item,i|
      is_last = items.size - 1 == i
      print_item(item, is_last, prefix)

      next_prefix = prefix + next_prefix(is_last)
      show_as_tree(item.children, next_prefix)
    end
  end

  def print_item(item, is_last, prefix)
    texts = item.texts

    texts.each_with_index do |t, i|
      if i == 0
        puts Color.black("#{prefix}#{prefix_head(is_last)}") + t
      else
        puts Color.black("#{prefix}#{prefix_body(is_last)}") + t
      end
    end
  end

  def next_prefix(is_last)
    is_last ? '      ' : ' │    '
  end

  def prefix_head(is_last)
    is_last ?  ' └─' : ' ├─'
  end

  def prefix_body(is_last)
    is_last ? "      " : " │    "
  end
end

class Color
  def self.g(t)
    "\e[32m" + t + Color.end_code
  end
  def self.b(t)
    "\e[34m" + t + Color.end_code
  end
  def self.r(t)
    "\e[31m" + t + Color.end_code
  end
  def self.m(t)
    "\e[35m" + t + Color.end_code
  end
  def self.black(t)
    "\e[30m" + t + Color.end_code
  end
  def self.end_code
    "\e[0m"
  end
end

class PrItem
  include TreeBuildable

  attr_accessor :params

  def initialize(params)
    @params = params
    @children = params[:children] || []
    @parent = params[:parent]
  end

  def has_key_in_parent_bases(key)
    return false if @parent.nil?

    if parent_key == key
      true
    else
      @parent.has_key_in_parent_bases(key)
    end
  end

  def parent_key
    @params[:base]
  end

  def key
    @params[:head]
  end

  def texts
    if @params[:number].nil?
      [Color.m("[#{@params[:head].to_s}]")]
    else
      behind_sym = @params[:is_latest] ? ' ' : Color.r("*")
      reviewers = @params[:reviewers].length > 0 ? Color.r(" > #{@params[:reviewers].join(' ')}") : ''
      title = "#{@params[:title].to_s} ##{@params[:number]}"
      [
        behind_sym + Color.m("[#{@params[:head].to_s}]") + reviewers,
        status + Color.g(title),
        Color.b(" #{@params[:user].to_s}") + Color.black(" #{@params[:url].to_s}")
      ]
    end
  end

  def user_like(keyword)
    return true if keyword.nil?
    (@params[:reviewers] | [@params[:user]]).any? {|u| u.include?(keyword) }
  end

  def reviewer_like(keyword)
    return true if keyword.nil?
    @params[:reviewers].any? {|u| u.include?(keyword) }
  end

  private

  def status
    case @params[:status]
    when 'success' then
      ''
    when 'failure' then
      Color.r('x ')
    when 'pending' then
      Color.r('o ')
    end
  end
end

main
